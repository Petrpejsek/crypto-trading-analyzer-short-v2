import type { FeaturesSnapshot, CoinRow } from '../../types/features'
import type { MarketRawSnapshot } from '../../types/market_raw'
import signalsCfg from '../../config/signals.json'
import candCfg from '../../config/candidates.json'

export type Candidate = {
  symbol: string
  score: number
  liquidityUsd: number
  atrPctH1: number
  emaOrderH1: string
  rsiM15?: number
  tier: 'SCOUT' | 'WATCH' | 'ALERT' | 'HOT'
  simSetup?: {
    side: 'LONG' | 'SHORT'
    entry: number
    stop: number
    tp1: number
    tp2: number
    rrr1: number
    risk_usd: number
    size_usd: number
  } | null
}

type SelectOpts = {
  decisionFlag: 'OK' | 'CAUTION' | 'NO-TRADE'
  allowWhenNoTrade?: boolean
  limit: number
  cfg: {
    atr_pct_min: number
    atr_pct_max: number
    min_liquidity_usdt: number
  }
}

export function selectCandidates(
  features: FeaturesSnapshot,
  _snapshot: MarketRawSnapshot,
  opts: SelectOpts & { canComputeSimPreview?: boolean; finalPickerStatus?: 'idle'|'loading'|'success'|'success_no_picks'|'error' }
): Candidate[] {
  const { decisionFlag, allowWhenNoTrade, limit, cfg } = opts
  if (decisionFlag === 'NO-TRADE' && !allowWhenNoTrade) return []
  const coins = features.universe || []
  // Hard gates (M2-Lite)
  const gates = (candCfg as any).hard_gates || {}
  const newGates = (candCfg as any).gates || {}
  const gateCounts: Record<string, number> = {
    gate_min_avg_trade_usdt: 0,
    gate_min_body_ratio_m15: 0,
    gate_max_upper_wick_ratio_m15: 0,
    gate_atr_pct_h1: 0,
    gate_quantile_ret_m15: 0,
    gate_quantile_rvol_h1: 0,
    gate_quantile_h1pos: 0,
  }
  const filtered = coins.filter(c => {
    // Strict volume gate: missing or low volume fails
    const volOk = (c.volume24h_usd ?? 0) >= (gates.min_quote_volume_usd ?? 0)
    const atrMin = (gates.atr_pct_h1_min ?? 0)
    const atrMax = (gates.atr_pct_h1_max ?? Infinity)
    let atrOk = true
    const atrVal = (c as any).atr_pct_H1
    if (Number.isFinite(atrVal)) {
      atrOk = (atrVal as number) >= atrMin && (atrVal as number) <= atrMax
      if (!atrOk) gateCounts.gate_atr_pct_h1++
    }
    const avgMin = (newGates.min_avg_trade_usdt ?? 0)
    const bodyMin = (newGates.min_body_ratio_m15 ?? 0)
    const wickMax = (newGates.max_upper_wick_ratio_m15 ?? 1)
    const avgTradeOk = (c.avg_trade_usdt ?? Infinity) >= avgMin
    // Apply M15-dependent gates only when metric exists; inclusive comparisons
    let bodyOk = true
    const bodyVal = (c as any).body_ratio_m15
    if (Number.isFinite(bodyVal)) {
      bodyOk = (bodyVal as number) >= bodyMin
      if (!bodyOk) gateCounts.gate_min_body_ratio_m15++
    }
    let wickOk = true
    const wickVal = (c as any).upper_wick_ratio_m15
    if (Number.isFinite(wickVal)) {
      wickOk = (wickVal as number) <= wickMax
      if (!wickOk) gateCounts.gate_max_upper_wick_ratio_m15++
    }
    if (!avgTradeOk) gateCounts.gate_min_avg_trade_usdt++
    return volOk && atrOk && avgTradeOk && bodyOk && wickOk
  })

  // Optional quantile gates (respect profile overrides)
  const prof: string = (candCfg as any)?.profile || 'lean'
  const profileCfg: any = (candCfg as any)?.profiles?.[prof] || {}
  const qBase = (candCfg as any)?.quantile_gates || {}
  const qcfg = {
    enabled: Boolean(profileCfg?.quantile_gates_enabled ?? qBase.enabled),
    ret_m15_q_min: Number(qBase.ret_m15_q_min ?? 0.65),
    rvol_h1_q_min: Number(qBase.rvol_h1_q_min ?? 0.7),
    h1_range_pos_q_min: Number(qBase.h1_range_pos_q_min ?? 0.7),
    apply_only_in_no_trade: Boolean(qBase.apply_only_in_no_trade ?? true)
  }
  let qFiltered = filtered
  if (qcfg.enabled && (!qcfg.apply_only_in_no_trade || decisionFlag === 'NO-TRADE')) {
    function qvalue(arr: number[], q: number): number {
      const a = [...arr].filter(x=>Number.isFinite(x)).sort((x,y)=>x-y)
      if (!a.length) return Infinity
      const pos = (a.length - 1) * Math.max(0, Math.min(1, q))
      const lo = Math.floor(pos), hi = Math.ceil(pos)
      if (lo === hi) return a[lo]
      const t = pos - lo
      return a[lo] * (1 - t) + a[hi] * t
    }
    const retQ = qvalue(filtered.map(c=>Number(c.ret_m15_pct)||0), Number(qcfg.ret_m15_q_min ?? 0.65))
    const rvolQ = qvalue(filtered.map(c=>Number(c.rvol_h1)||0), Number(qcfg.rvol_h1_q_min ?? 0.7))
    const posQ = qvalue(filtered.map(c=>Number(c.h1_range_pos_pct)||0), Number(qcfg.h1_range_pos_q_min ?? 0.7))
    const afterQ: CoinRow[] = []
    for (const c of filtered) {
      const gateReasons: string[] = []
      // Apply quantile gates only when metric exists (avoid penalizing missing M15)
      const hasRetM15 = Number.isFinite(c.ret_m15_pct as any)
      const hasRvolH1 = Number.isFinite(c.rvol_h1 as any)
      const hasH1Pos = Number.isFinite(c.h1_range_pos_pct as any)
      if (hasRetM15 && (c.ret_m15_pct as any) < retQ) gateReasons.push('q_ret_m15')
      if (hasRvolH1 && (c.rvol_h1 as any) < rvolQ) gateReasons.push('q_rvol_h1')
      if (hasH1Pos && (c.h1_range_pos_pct as any) < posQ) gateReasons.push('q_h1pos')
      if (gateReasons.length === 0) afterQ.push(c as any)
      else {
        if (gateReasons.includes('q_ret_m15')) gateCounts.gate_quantile_ret_m15++
        if (gateReasons.includes('q_rvol_h1')) gateCounts.gate_quantile_rvol_h1++
        if (gateReasons.includes('q_h1pos')) gateCounts.gate_quantile_h1pos++
        ;(c as any).gated_by = gateReasons.join(',')
      }
    }
    qFiltered = afterQ
  }
  function rank(values: Array<number | null | undefined>, v: number | null | undefined) {
    const arr = values.filter((x): x is number => Number.isFinite(x as any))
    if (!arr.length || !Number.isFinite(v as any)) return 0
    const sorted = [...arr].sort((a,b)=>a-b)
    const idx = sorted.findIndex(x => x >= (v as number))
    const r = (idx < 0 ? sorted.length - 1 : idx) / Math.max(1, sorted.length - 1)
    return r
  }
  // SHORT preselect logic: two branches (overextended and downtrend), 25+25
  const LIQ_MIN = 100000
  const SPREAD_MAX_BPS = 10
  const MIN_AGE_HOURS = 24 * 7
  const isPerp = (c: any) => (String((c as any)?.market_type || 'perp').toLowerCase() === 'perp')
  const commonOk = (c: any): boolean => {
    const liqOk = Number(c.volume24h_usd || 0) >= LIQ_MIN
    const spreadOk = !Number.isFinite((c as any).spread_bps) || Number((c as any).spread_bps) <= SPREAD_MAX_BPS
    const ageOk = !Number.isFinite((c as any).age_hours) || Number((c as any).age_hours) >= MIN_AGE_HOURS
    return liqOk && spreadOk && ageOk && isPerp(c)
  }
  // Overextended/up: large 24h gain, RSI high, price >> EMA, funding positive and increasing (approx by funding_z>0)
  const overextended = filtered.filter(c => {
    if (!commonOk(c)) return false
    const ret24 = Number((c as any).ret_24h_pct || c.ret_h1_pct || 0)
    const rsiH1 = Number((c as any).RSI_H1 || 0)
    const rsiM15 = Number((c as any).RSI_M15 || 0)
    const px = Number(c.price || 0)
    const ema20 = Number((c as any).ema20_H1 || NaN)
    const ema50 = Number((c as any).ema50_H1 || NaN)
    const ema200 = Number((c as any).ema200_H1 || NaN)
    const atrPct = Number(c.atr_pct_H1 || 0)
    const funding = Number(c.funding || 0)
    const fz = Number((c as any).funding_z || 0)
    const dist20 = Number.isFinite(ema20) && px ? Math.abs((px - ema20) / px) : 0
    const dist50 = Number.isFinite(ema50) && px ? Math.abs((px - ema50) / px) : 0
    const dist200 = Number.isFinite(ema200) && px ? Math.abs((px - ema200) / px) : 0
    const distOk = atrPct && ((dist20 > 0.015 * atrPct) || (dist50 > 0.015 * atrPct) || (dist200 > 0.015 * atrPct))
    const rsiOk = (rsiH1 > 70) || (rsiM15 > 75)
    const fundOk = (funding > 0) && (fz > 0)
    return (ret24 > 0) && rsiOk && distOk && fundOk
  }).sort((a,b)=> (Number((b as any).ret_24h_pct || b.ret_h1_pct || 0) - Number((a as any).ret_24h_pct || a.ret_h1_pct || 0)) || (Number((b as any).RSI_H1||0) - Number((a as any).RSI_H1||0)))
  // Downtrend continuation: large losers, RSI low, below EMA20/50 (and 20<50<200 if known), funding negative and OI decreasing
  const downtrend = filtered.filter(c => {
    if (!commonOk(c)) return false
    const ret24 = Number((c as any).ret_24h_pct || c.ret_h1_pct || 0)
    const rsiH1 = Number((c as any).RSI_H1 || 50)
    const rsiM15 = Number((c as any).RSI_M15 || 50)
    const px = Number(c.price || 0)
    const ema20 = Number((c as any).ema20_H1 || NaN)
    const ema50 = Number((c as any).ema50_H1 || NaN)
    const ema200 = Number((c as any).ema200_H1 || NaN)
    const below20 = Number.isFinite(ema20) && px < (ema20 as number)
    const below50 = Number.isFinite(ema50) && px < (ema50 as number)
    const orderedDown = Number.isFinite(ema20) && Number.isFinite(ema50) && Number.isFinite(ema200) ? (ema20 < ema50 && ema50 < ema200) : false
    const funding = Number(c.funding || 0)
    const oiChg = Number((c as any).oi_change_pct_h1 || 0)
    const rsiOk = (rsiH1 < 40) && (rsiM15 < 35)
    const trendOk = below20 && below50 && (orderedDown || true)
    const flowOk = (funding < 0) && (oiChg <= 0)
    return (ret24 < 0) && rsiOk && trendOk && flowOk
  }).sort((a,b)=> (Number((a as any).ret_24h_pct || a.ret_h1_pct || 0) - Number((b as any).ret_24h_pct || b.ret_h1_pct || 0)) || (Number((a as any).RSI_H1||50) - Number((b as any).RSI_H1||50)))

  const topA = overextended.slice(0, 25)
  const topB = downtrend.slice(0, 25)
  const pool = [...topA, ...topB]
  // Keep original tie-breakers to stabilize ordering slightly
  const poolRanked = pool
    .sort((a, b) => a.symbol.localeCompare(b.symbol))
    .slice(0, Math.max(1, Math.min((limit as any) ?? 50, 50)))
  // Persist lastTopK for sticky (best-effort)
  try { localStorage.setItem('lastTopK', JSON.stringify({ ts: Date.now(), items: poolRanked.map((r,i)=>({ symbol: r.symbol, S: r.score ?? 0, rank: i+1 })) })) } catch {}
  return poolRanked
  // Persist gate stats (optional, behind try/catch; feature-flag removed)
  try { localStorage.setItem('cand_gate_stats', JSON.stringify({ ts: Date.now(), universe: coins.length, counts: gateCounts })) } catch {}

  const lastTopRaw = (()=>{ try { return JSON.parse(localStorage.getItem('lastTopK')||'') } catch { return null } })()
  const lastTs = lastTopRaw?.ts as number | undefined
  const lastMap: Record<string, { S: number, rank: number }> = {}
  try { for (const [idx, it] of (lastTopRaw?.items || []).entries()) lastMap[it.symbol] = { S: Number(it.S)||0, rank: idx+1 } } catch {}

  // Determine effective TopK (profile -> base -> env override for Node runner)
  let desiredTopK = Number(profileCfg?.topK ?? (candCfg as any)?.topK ?? 12)
  try {
    const envTop = (typeof process !== 'undefined' && (process as any)?.env?.CAND_TOPK) ? Number((process as any).env.CAND_TOPK) : NaN
    if (Number.isFinite(envTop) && envTop > 0) desiredTopK = envTop
  } catch {}

  const ranked = qFiltered
    .map((c: CoinRow) => {
      const orig = (candCfg as any)
      let score = scoreOf(c)
      const stickyCfg = (candCfg as any)?.sticky || {}
      const stickyEnabled: boolean = Boolean(profileCfg?.sticky_enabled ?? stickyCfg.enabled)
      if (stickyEnabled && lastTs && lastMap[c.symbol]) {
        const minutes = Math.max(0, Math.floor((Date.now() - lastTs) / 60000))
        const stickyMin = Number(stickyCfg.sticky_minutes ?? 30)
        if (minutes <= stickyMin) {
          const prev = lastMap[c.symbol]
          const delta = Math.abs(Number(score) - Number(prev.S))
          const deltaMax = Number(stickyCfg.delta_s_max ?? 0.02)
          if (delta <= deltaMax) {
            const bonusMax = Number(stickyCfg.bonus_max ?? 0.015)
            const bonus = bonusMax * (1 - (minutes / stickyMin))
            score = Number(Math.max(0, Math.min(1, score + bonus)).toFixed(4))
            ;(c as any).contrib_sticky_bonus = bonus
            ;(c as any).S_after_sticky = score
          }
        }
      }
      let tier: Candidate['tier'] = 'SCOUT'
      if (score >= 80) tier = 'HOT'
      else if (score >= 65) tier = 'ALERT'
      else if (score >= 50) tier = 'WATCH'
      const base: Candidate = {
        symbol: c.symbol,
        score,
        liquidityUsd: c.volume24h_usd ?? 0,
        atrPctH1: c.atr_pct_H1 ?? 0,
        emaOrderH1: (c.ema_order_H1 as any) ?? '',
        rsiM15: (c.RSI_M15 ?? undefined) as number | undefined,
        tier,
      }
      // optional mock setup in preview mode (guarded, no-fallback)
      const canSim = Boolean(opts.canComputeSimPreview) && (opts.finalPickerStatus !== 'error')
      if (canSim && (signalsCfg as any)?.preview?.computeMockSetup) {
        const m = buildMockSetup(c, signalsCfg as any)
        if (m) base.simSetup = m
      }
      ;(base as any).prev_rank = lastMap[c.symbol]?.rank ?? Infinity
      ;(base as any).S_after_sticky = (c as any).S_after_sticky ?? score
      return base
    })
    .sort((a, b) => {
      return (b.score - a.score) || ((b as any).rvol_h1 - (a as any).rvol_h1) || ((b as any).ret_m15_pct - (a as any).ret_m15_pct) || a.symbol.localeCompare(b.symbol)
    })
    // Always enforce configured TopK after sorting. Allow an optional additional cap via opts.limit for UI preview use-cases.
    .slice(0, Math.max(1, Math.min(desiredTopK, Number.isFinite(limit as any) ? Number(limit) : desiredTopK)))
  // Persist lastTopK for sticky (best-effort)
  try { localStorage.setItem('lastTopK', JSON.stringify({ ts: Date.now(), items: ranked.map((r,i)=>({ symbol: r.symbol, S: r.score, rank: i+1 })) })) } catch {}
  return ranked
}

// Deterministic mock setup builder for preview-only levels
export function buildMockSetup(c: CoinRow, cfg: any) {
  const preview = (cfg?.preview) || {}
  const px = c.price ?? null
  const atrPct = c.atr_pct_H1 ?? null
  const emaOrder = c.ema_order_H1
  const rsi = c.RSI_M15 ?? 50
  if (!px || !Number.isFinite(px)) return null
  if (!atrPct || !Number.isFinite(atrPct)) return null
  if (atrPct < (preview.min_atr_pct ?? 0.25) || atrPct > (preview.max_atr_pct ?? 8)) return null

  let side: 'LONG' | 'SHORT' | null = null
  // SHORT-only project: only bearish setups allowed
  if ((emaOrder === '200>50>20') && rsi <= 55) side = 'SHORT'
  else return null  // Skip bullish patterns (20>50>200)

  const atrPx = px * (atrPct / 100)
  const entryOff = preview.entry_offset_atr ?? 0.2
  const slOff = preview.sl_offset_atr ?? 1.2
  const tp1rr = preview.tp1_rrr ?? 1.5
  const tp2rr = preview.tp2_rrr ?? 2.5
  let entry: number, stop: number, tp1: number, tp2: number
  // SHORT-only calculations (side will always be 'SHORT' at this point)
  entry = px + entryOff * atrPx
  stop = entry + slOff * atrPx
  tp1 = entry - tp1rr * (stop - entry)
  tp2 = entry - tp2rr * (stop - entry)
  if (![entry, stop, tp1, tp2].every(x => Number.isFinite(x) && x > 0)) return null
  // SHORT validation: stop must be above entry
  if (stop <= entry) return null

  const eq = preview.account_equity_usd_preview ?? 10000
  const riskPct = preview.risk_per_trade_pct_preview ?? 0.3
  const riskUsd = Math.max(0, (eq * riskPct) / 100)
  const riskPerUnit = Math.abs(entry - stop)
  const sizeUsd = riskPerUnit > 0 ? riskUsd * (entry / riskPerUnit) : 0
  return { side, entry, stop, tp1, tp2, rrr1: tp1rr, risk_usd: riskUsd, size_usd: Math.max(0, sizeUsd) }
}


